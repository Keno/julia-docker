--- binutils/winduni.c.old	2017-10-25 21:34:22.000000000 -0400
+++ binutils/winduni.c	2017-10-25 21:48:51.000000000 -0400
@@ -744,10 +744,32 @@
 #endif /* HAVE_ICONV */
 
 static rc_uint_type
+ascii_MultiByteToWideChar(const char *mb,
+        unichar *u, rc_uint_type u_len)
+{
+  rc_uint_type ret = strlen (mb) + 1;
+  ret *= sizeof (unichar);
+  if (u != NULL && u_len != 0)
+    {
+      do
+  {
+    *u++ = ((unichar) *mb) & 0xff;
+    --u_len; mb++;
+  }
+      while (u_len != 0 && mb[-1] != 0);
+    }
+  if (u != NULL && u_len != 0)
+    *u = 0;
+  return ret;
+}
+
+static rc_uint_type
 wind_MultiByteToWideChar (rc_uint_type cp, const char *mb,
 			  unichar *u, rc_uint_type u_len)
 {
   rc_uint_type ret = 0;
+  if (cp == 0)
+    return ascii_MultiByteToWideChar(mb, u, u_len);
 
 #if defined (_WIN32) || defined (__CYGWIN__)
   rc_uint_type conv_flags = MB_PRECOMPOSED;
@@ -772,6 +794,11 @@
   if (!mb || !iconv_name)
     return 0;
   iconv_t cd = iconv_open ("UTF-16LE", iconv_name);
+  if (cd == (iconv_t)-1) {
+    // Fall back to the ascii method. Not necessarily correct,
+    // but better than crashing.
+    return ascii_MultiByteToWideChar(mb, u, u_len);
+  }
 
   while (1)
     {
@@ -808,21 +835,7 @@
     }
   iconv_close (cd);
 #else
-  if (cp)
-    ret = 0;
-  ret = strlen (mb) + 1;
-  ret *= sizeof (unichar);
-  if (u != NULL && u_len != 0)
-    {
-      do
-	{
-	  *u++ = ((unichar) *mb) & 0xff;
-	  --u_len; mb++;
-	}
-      while (u_len != 0 && mb[-1] != 0);
-    }
-  if (u != NULL && u_len != 0)
-    *u = 0;
+  ret = ascii_MultiByteToWideChar(mb, u, u_len);
 #endif
   return ret;
 }

