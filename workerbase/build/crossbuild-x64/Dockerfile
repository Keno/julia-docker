## This file was autogenerated
# Do not edit directly; edit the .harbor files
#
# To build this docker image via `make`, run `make build-crossbuild-x64` in the `workerbase` directory
# To build this docker image manually, run `docker build --pull -t staticfloat/julia_workerbase:crossbuild-x64 .`

# Build an image that contains all of our cross compilers and all that stuff.
# Since we need virtually everything within the actual workerbase image, just
# build off of that one instead of compiling it all over again
FROM ubuntu:trusty

# Setup a few things we need in order to make it through the build properly
MAINTAINER Elliot Saba <staticfloat@gmail.com>
USER root

# We create a `buildworker` user so that we don't have to run everything as root
RUN useradd -u 1337 -m -s /bin/bash buildworker || true

# These are where we'll do all our work, so make them now
RUN mkdir -p /src /downloads
RUN chown buildworker:buildworker /src /downloads

# We use the "download_unpack.sh" command a lot, throw it into /usr/bin
COPY download_unpack.sh /usr/bin

# We want to be able to do things like "source"
SHELL ["/bin/bash", "-c"]

# Install build tools (BUILD_TOOLS are things needed during the build, but not at runtime)
ARG TEMPORARY_DEPS="gcc-multilib gcc g++ clang libfuse-dev libfreetype6-dev libtiff-dev libgl1-mesa-dev linux-headers-generic"
RUN apt update && apt install -y ${TEMPORARY_DEPS} sudo curl make patch tar gawk autoconf python libtool git bison flex pkg-config zip unzip gdb xz-utils lib32z1
RUN echo "buildworker ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
RUN sed -i.bak -e 's/Defaults[[:space:]]*env_reset//g' /etc/sudoers
RUN sed -i.bak -e 's/Defaults[[:space:]]*secure_path=.*//g' /etc/sudoers
USER buildworker

# We still need a pretty recent cmake, so just build one from scratch like usual
## Install cmake into /usr/local
ARG cmake_version=3.6.3
ARG cmake_url=https://cmake.org/files/v3.6/cmake-${cmake_version}.tar.gz

USER buildworker
WORKDIR /src

# Unfortunately, we have to pass `-k` to `curl` because cmake.org has weird SSL
# certificates, and old versions of `curl` can't deal with it.  :(
RUN EXTRA_CURL_FLAGS="-k" download_unpack.sh "${cmake_url}"

# Build the cmake sources!
WORKDIR /src/cmake-${cmake_version}
RUN ${L32} ./configure --prefix=/usr/local
RUN ${L32} make -j4

# Install as root
USER root
RUN ${L32} make install

# Now cleanup /src
WORKDIR /src
RUN rm -rf cmake-${cmake_version}
## Install GCC
ARG gcc_version=7.2.0
ARG gcc_url=https://mirrors.kernel.org/gnu/gcc/gcc-${gcc_version}/gcc-${gcc_version}.tar.xz

# Download and unpack gcc
USER buildworker
WORKDIR /src
RUN download_unpack.sh "${gcc_url}"

# Build gcc!
WORKDIR /src/gcc-${gcc_version}
RUN ${L32} contrib/download_prerequisites
RUN mkdir -p /src/gcc-${gcc_version}_build
WORKDIR /src/gcc-${gcc_version}_build
RUN ${L32} /src/gcc-${gcc_version}/configure \
    --prefix=/usr/local --enable-host-shared --enable-threads=posix \
    --enable-languages=c,c++,fortran,objc,obj-c++ --disable-multilib ${gcc_configure_flags}
RUN ${L32} make -j4

# Install gcc
USER root
RUN ${L32} make install

# Symlink LTO plugin into binutils directory
RUN mkdir -p /usr/local/lib/bfd-plugins
RUN ln -sf $(find /usr/local/libexec/gcc/ -name liblto_plugin.so) /usr/local/lib/bfd-plugins/

# Setup environment variables so that GCC takes precedence from this point on
ENV PATH "/usr/local/bin:$PATH"

# Put our /lib and /lib64 directories into /etc/ld.so.conf.d so that they take precedence
RUN echo "/usr/local/lib"    > /etc/ld.so.conf.d/0_new_gcc.conf
RUN echo "/usr/local/lib64" >> /etc/ld.so.conf.d/0_new_gcc.conf
RUN ldconfig

# Add a `cc` symlink to gcc:
RUN ln -sf /usr/local/bin/gcc /usr/local/bin/cc

# Now cleanup /src
WORKDIR /src
RUN rm -rf gcc-${gcc_version}*

# Get our bash script library ready
COPY build_crosscompiler.sh /build.sh
COPY patches /downloads/patches

# build gcc for x86_64.  Use an especially old glibc version to maximize compatibility
ENV target="x86_64-linux-gnu"
ENV glibc_version=2.12.2
RUN source /build.sh; set -e; install_kernel_headers
RUN source /build.sh; set -e; install_binutils
RUN source /build.sh; set -e; install_gcc_stage1
RUN source /build.sh; set -e; install_glibc_stage1
RUN source /build.sh; set -e; install_gcc_stage2
RUN source /build.sh; set -e; install_glibc_stage2
RUN source /build.sh; set -e; install_gcc_stage3
ENV glibc_version=""

# build gcc for i686.  Again use an especially old glibc version to maximize compatibility
ENV target="i686-linux-gnu"
ENV L32="linux32"
ENV glibc_version=2.12.2
RUN source /build.sh; set -e; install_kernel_headers
RUN source /build.sh; set -e; install_binutils
RUN source /build.sh; set -e; install_gcc_stage1
RUN source /build.sh; set -e; install_glibc_stage1
RUN source /build.sh; set -e; install_gcc_stage2
RUN source /build.sh; set -e; install_glibc_stage2
RUN source /build.sh; set -e; install_gcc_stage3
ENV L32=""
ENV glibc_version=""

# build for mac64
ENV target="x86_64-apple-darwin14"
RUN source /build.sh; set -e; install_osx_sdk
RUN source /build.sh; set -e; install_libtapi
RUN source /build.sh; set -e; install_cctools
RUN source /build.sh; set -e; install_dsymutil
RUN source /build.sh; set -e; install_gcc_stage1
RUN source /build.sh; set -e; install_gcc_stage2
RUN source /build.sh; set -e; install_gcc_stage3


# build for win64/win32
ENV target="x86_64-w64-mingw32"
RUN source /build.sh; install_binutils
RUN source /build.sh; install_mingw_stage1
RUN source /build.sh; install_gcc_stage1
RUN source /build.sh; install_mingw_stage2
RUN source /build.sh; install_gcc_stage2
RUN source /build.sh; install_gcc_stage3
ENV target="i686-w64-mingw32"
RUN source /build.sh; install_binutils
RUN source /build.sh; install_mingw_stage1
RUN source /build.sh; install_gcc_stage1
RUN source /build.sh; install_mingw_stage2
RUN source /build.sh; install_gcc_stage2
RUN source /build.sh; install_gcc_stage3

# build for arm7/arm8
ENV target="aarch64-linux-gnu"
RUN source /build.sh; set -e; install_kernel_headers
RUN source /build.sh; set -e; install_binutils
RUN source /build.sh; set -e; install_gcc_stage1
RUN source /build.sh; set -e; install_glibc_stage1
RUN source /build.sh; set -e; install_gcc_stage2
RUN source /build.sh; set -e; install_glibc_stage2
RUN source /build.sh; set -e; install_gcc_stage3
ENV target="arm-linux-gnueabihf"
RUN source /build.sh; set -e; install_kernel_headers
RUN source /build.sh; set -e; install_binutils
RUN source /build.sh; set -e; install_gcc_stage1
RUN source /build.sh; set -e; install_glibc_stage1
RUN source /build.sh; set -e; install_gcc_stage2
RUN source /build.sh; set -e; install_glibc_stage2
RUN source /build.sh; set -e; install_gcc_stage3

# build gcc for ppc64le (we need a more recent glibc here as well)
# We require at least version 2.22 for the fixes to assembler problems:
# https://sourceware.org/bugzilla/show_bug.cgi?id=18116
# We require at least version 2.24 for the fixes to memset.S:
# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=843691
ENV target="powerpc64le-linux-gnu"
ENV glibc_version=2.25
RUN source /build.sh; set -e; install_kernel_headers
RUN source /build.sh; set -e; install_binutils
RUN source /build.sh; set -e; install_gcc_stage1
RUN source /build.sh; set -e; install_glibc_stage1
RUN source /build.sh; set -e; install_gcc_stage2
RUN source /build.sh; set -e; install_glibc_stage2
RUN source /build.sh; set -e; install_gcc_stage3
ENV glibc_version=""
ENV target=""

# Clear out our custom-built native GCC
RUN rm -rf /usr/local/bin/* /usr/local/lib/gcc /usr/local/lib64/* /usr/local/libexec/gcc /usr/local/include/c++

# Override normal uname with something that fakes out based on ${target}
USER root
COPY fake_uname.sh /usr/local/bin/uname
RUN chmod +x /usr/local/bin/uname

USER root

# We need to override ld.so.conf to search /usr/local before /usr
RUN echo "/usr/local/lib64" > /etc/ld.so.conf.new; \
    echo "/usr/local/lib" >> /etc/ld.so.conf.new; \
    cat /etc/ld.so.conf >> /etc/ld.so.conf.new; \
    mv /etc/ld.so.conf.new /etc/ld.so.conf; \
    ldconfig

# Cleanup downloads
RUN rm -rf /downloads

# Remove bootstrapping compiler toolchain if we need to
RUN if [[ -n "${TEMPORARY_DEPS}" ]]; then \
        if [[ -n "$(which yum 2>/dev/null)" ]]; then \
            yum remove -y ${TEMPORARY_DEPS}; \
            yum clean all; \
        elif [[ -n "$(which apt-get 2>/dev/null)" ]]; then \
            apt-get remove -y ${TEMPORARY_DEPS}; \
            apt-get autoremove -y; \
            apt-get clean -y; \
        fi; \
    fi

# Set a default working directory that we know is good
WORKDIR /

# Use /entrypoint.sh to conditionally apply ${L32} since we cna't use ARG
# values within an actual ENTRYPOINT command.  :(
RUN echo "#!/bin/bash" > /entrypoint.sh; \
    echo "${L32} \"\$@\"" >> /entrypoint.sh; \
    chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
CMD ["/bin/bash"]
USER buildworker
