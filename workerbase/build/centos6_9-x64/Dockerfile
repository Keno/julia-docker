## This file was autogenerated
# Do not edit directly; edit the .harbor files
#
# To build this docker image via `make`, run `make build-centos6_9-x64` in the `workerbase` directory
# To build this docker image manually, run `docker build --pull -t staticfloat/julia_workerbase:centos6_9-x64 .`

FROM centos:6.9




MAINTAINER Elliot Saba <staticfloat@gmail.com>
USER root

# We create a `buildworker` user so that we don't have to run everything as root
RUN useradd -u 1337 -m -s /bin/bash buildworker || true

# These are where we'll do all our work, so make them now
RUN mkdir -p /src /downloads
RUN chown buildworker:buildworker /src /downloads

# We use the "download_unpack.sh" command a lot, throw it into /usr/bin
COPY download_unpack.sh /usr/bin

# Add ourselves to sudoers
RUN mkdir -p /etc/sudoers.d
RUN echo "buildworker ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/buildworker

# We want to be able to do things like "source"
SHELL ["/bin/bash", "-c"]
## Download and install needed build dependencies for x86_64 yum-based systems
USER root
RUN ${L32} yum update -y

# Tools that make it easy to get stuff done within the docker image
ARG NICE_TOOLS="vim curl gdb net-tools which patchelf sudo"

# Tools to bootstrap our compiler chain that we will remove afterward
ARG TEMPORARY_DEPS="gcc gcc-c++ glibc-devel.i686 glibc-devel"

# Tools that we need to build Julia and other deps that we are not going to
# build ourselves
ARG BUILD_DEPS="make m4 openssl openssl-devel patch pkg-config curl-devel \
               expat-devel gettext-devel perl-devel wget bzip2 tar \ 
               zlib-devel bzip2-devel xz rpmdevtools"

# Install all these packages
RUN ${L32} yum install -y ${NICE_TOOLS} ${TEMPORARY_DEPS} ${BUILD_DEPS}

# Fixup sudo problems
RUN ${L32} sed -i.bak -e 's/Defaults[[:space:]]*env_reset//g' /etc/sudoers
RUN ${L32} sed -i.bak -e 's/Defaults[[:space:]]*secure_path[[:space:]]*=.*//g' /etc/sudoers
# Download and install `tar` because some machines have it too old and don't
# know what `.xz` files are.  Build it first so that we can use it to extract
# our other tools.  Yes, this means this is the only tool that's not built with
# our new GCC, but that's okay.
USER buildworker
## Install tar
ARG tar_version=1.29
ARG tar_url=https://ftp.gnu.org/gnu/tar/tar-${tar_version}.tar.gz

USER buildworker
WORKDIR /src

# Use download_unpack to download and unpack tar
RUN download_unpack.sh "${tar_url}"

# Build the tar sources!
WORKDIR /src/tar-${tar_version}
# Set CPPFLAGS because of this link: https://goo.gl/lKju1q
RUN $L32 ./configure --prefix=/usr/local CPPFLAGS="-fgnu89-inline"
RUN $L32 make -j4

# Install tar
USER root
RUN $L32 make install

# We need to pretend to be `gtar` as well
RUN ln -s /usr/local/bin/tar /usr/local/bin/gtar

# Now cleanup /src
WORKDIR /src
# Sigh, see https://github.com/docker/docker/issues/13451 for context
RUN rm -rf tar-${tar_version}* || \
    (mv tar-${tar_version}/confdir3/confdir3 tar-${tar_version}/confdir4 && \
    rm -rf tar-${tar_version}*)

# Download and install `gcc` because we want only the latest in cutting-edge
# compiler technology, and also because LLVM is a needy little piece of software
USER buildworker
## Install binutils
ARG binutils_version=2.29.1
ARG binutils_url=https://ftp.gnu.org/gnu/binutils/binutils-${binutils_version}.tar.xz

# Use download_unpack to download and unpack binutils and gcc
WORKDIR /src
RUN download_unpack.sh "${binutils_url}"

# Build binutils!  Because it's cheap and easy, we enable essentially every
# target under the sun for binutils
WORKDIR /src/binutils-${binutils_version}
RUN ${L32} ./configure --prefix=/usr/local \
                       ${binutils_configure_flags}
RUN ${L32} make -j4

# Install binutils
USER root
RUN ${L32} make install

# Cleanup
WORKDIR /src
RUN rm -rf binutils-${binutils_version}
USER buildworker
## Install GCC
ARG gcc_version=7.2.0
ARG gcc_url=https://mirrors.kernel.org/gnu/gcc/gcc-${gcc_version}/gcc-${gcc_version}.tar.xz

# Download and unpack gcc
USER buildworker
WORKDIR /src
RUN download_unpack.sh "${gcc_url}"

# Build gcc!
WORKDIR /src/gcc-${gcc_version}
RUN ${L32} contrib/download_prerequisites
RUN mkdir -p /src/gcc-${gcc_version}_build
WORKDIR /src/gcc-${gcc_version}_build
RUN ${L32} /src/gcc-${gcc_version}/configure \
    --prefix=/usr/local --enable-host-shared --enable-threads=posix \
    --with-system-zlib --enable-multilib \
    --enable-languages=c,c++,fortran,objc,obj-c++ ${gcc_configure_flags}
RUN ${L32} make -j4

# Install gcc
USER root
RUN ${L32} make install

# Symlink LTO plugin into binutils directory
RUN mkdir -p /usr/local/lib/bfd-plugins
RUN ln -sf $(find /usr/local/libexec/gcc/ -name liblto_plugin.so) /usr/local/lib/bfd-plugins/

# Setup environment variables so that GCC takes precedence from this point on
ENV PATH "/usr/local/bin:$PATH"

# Put our /lib and /lib64 directories into /etc/ld.so.conf.d so that they take precedence
RUN echo "/usr/local/lib"    > /etc/ld.so.conf.d/0_new_gcc.conf
RUN echo "/usr/local/lib64" >> /etc/ld.so.conf.d/0_new_gcc.conf
RUN ldconfig

# Add a `cc` symlink to gcc:
RUN ln -sf /usr/local/bin/gcc /usr/local/bin/cc

# Now cleanup /src
WORKDIR /src
RUN rm -rf gcc-${gcc_version}*

# Download and install `libtool` based off of our GCC version
USER buildworker
## Install libtool
ARG libtool_version=2.4.6
ARG libtool_url=http://ftpmirror.gnu.org/libtool/libtool-${libtool_version}.tar.gz

USER buildworker
WORKDIR /src

# Use download_unpack to download and unpack libtool
RUN download_unpack.sh "${libtool_url}"
WORKDIR /src/libtool-${libtool_version}
RUN ${L32} ./configure --prefix=/usr/local
RUN ${L32} make all -j4

# Install libtool
USER root
RUN ${L32} make install

# cleanup /src
WORKDIR /src
RUN rm -rf libtool-${libtool_version}

# Download and install `git` because some of the distributions we build on are
# old enough that `git` isn't even installable from the default distributions
USER buildworker
## Install git
ARG git_version=2.11.0
ARG git_url=https://github.com/git/git/archive/v${git_version}.tar.gz

USER buildworker
WORKDIR /src

# Use download_unpack to download and unpack git
RUN download_unpack.sh "${git_url}" /downloads/git-${git_version}.tar.gz
WORKDIR /src/git-${git_version}
RUN ${L32} make prefix=/usr/local all -j4

# Install git
USER root
RUN ${L32} make prefix=/usr/local install

# cleanup /src
WORKDIR /src
RUN rm -rf git-${git_version}

# Download and install `cmake` because LLVM again.  Whiner.
USER buildworker
## Install cmake into /usr/local
ARG cmake_version=3.6.3
ARG cmake_url=https://cmake.org/files/v3.6/cmake-${cmake_version}.tar.gz

WORKDIR /src

# Unfortunately, we have to pass `-k` to `curl` because cmake.org has weird SSL
# certificates, and old versions of `curl` can't deal with it.  :(
RUN EXTRA_CURL_FLAGS="-k" download_unpack.sh "${cmake_url}"

# Build the cmake sources!
WORKDIR /src/cmake-${cmake_version}
RUN ${L32} ./configure --prefix=/usr/local
RUN ${L32} make -j4

# Install as root
USER root
RUN ${L32} make install

# Now cleanup /src
WORKDIR /src
RUN rm -rf cmake-${cmake_version}

# Download and install `python` because buildbot doesn't like ancient versions
USER buildworker
## Install python
ARG python_version=2.7.13
ARG python_url=https://www.python.org/ftp/python/${python_version}/Python-${python_version}.tar.xz
ARG pip_url=https://bootstrap.pypa.io/get-pip.py

USER buildworker
WORKDIR /src

# Use download_unpack to download and unpack python
RUN download_unpack.sh "${python_url}"

# Build the python sources!
WORKDIR /src/Python-${python_version}
RUN ${L32} ./configure --prefix=/usr/local
RUN ${L32} make -j4

# Install python
USER root
RUN ${L32} make install

# Install pip and install virtualenv (all as root, of course)
RUN curl -q -# -L "${pip_url}" -o get-pip.py
RUN python ./get-pip.py
RUN pip install virtualenv

# Now cleanup /src
WORKDIR /src
RUN rm -rf Python-${python_version}
RUN rm -f get-pip.py

# Download and install `ccache` to speed up compilation
USER buildworker
## Install ccache
ARG ccache_version=3.3.4
ARG ccache_url=https://www.samba.org/ftp/ccache/ccache-${ccache_version}.tar.xz

USER buildworker
WORKDIR /src

# Use download_unpack to download and unpack ccache
RUN download_unpack.sh "${ccache_url}"

WORKDIR /src/ccache-${ccache_version}
# We need to patch ccache's configure system since it's ancient
RUN curl -L 'https://raw.githubusercontent.com/jd-gascuel/ccache/437b5ff4ca7bbcabd225816132e4665180cfa18e/config.guess' > config.guess
RUN curl -L 'https://raw.githubusercontent.com/jd-gascuel/ccache/437b5ff4ca7bbcabd225816132e4665180cfa18e/config.sub' > config.sub
RUN ${L32} ./configure --prefix=/usr/local
RUN ${L32} make all -j4

# Install ccache
USER root
RUN ${L32} make install

# cleanup /src
WORKDIR /src
RUN rm -rf ccache-${ccache_version}

COPY build_crosscompiler.sh /build.sh
COPY patches /downloads/patches

# Also install windows cross-compilers
ENV target="x86_64-w64-mingw32"
USER buildworker
RUN source /build.sh; install_binutils
RUN source /build.sh; download_gcc
RUN source /build.sh; install_gcc_bootstrap
RUN source /build.sh; install_mingw_stage1
RUN source /build.sh; install_mingw_stage2
RUN source /build.sh; install_gcc

# Install Wine
USER root
RUN yum install -y libstdc++.i686 flex bison
USER buildworker
USER buildworker
WORKDIR /src

ARG wine_version=2.0.3

RUN git clone https://github.com/wine-mirror/wine.git -b wine-${wine_version}
WORKDIR /src/wine
RUN ./configure --without-x --without-freetype --enable-win64
RUN make -j3

USER root
RUN make install
WORKDIR /src
RUN rm -rf wine
ENV WINEARCH=win64

USER root
RUN rm -f /build.sh
USER root

# We need to override ld.so.conf to search /usr/local before /usr
RUN echo "/usr/local/lib64" > /etc/ld.so.conf.new; \
    echo "/usr/local/lib" >> /etc/ld.so.conf.new; \
    cat /etc/ld.so.conf >> /etc/ld.so.conf.new; \
    mv /etc/ld.so.conf.new /etc/ld.so.conf; \
    ldconfig

# Cleanup downloads
RUN rm -rf /downloads

# Remove bootstrapping compiler toolchain if we need to
RUN if [[ -n "${TEMPORARY_DEPS}" ]]; then \
        if [[ -n "$(which yum 2>/dev/null)" ]]; then \
            yum remove -y ${TEMPORARY_DEPS}; \
            yum clean all; \
        elif [[ -n "$(which apt-get 2>/dev/null)" ]]; then \
            apt-get remove -y ${TEMPORARY_DEPS}; \
            apt-get autoremove -y; \
            apt-get clean -y; \
        fi; \
    fi

# Set a default working directory that we know is good
WORKDIR /

# Use /entrypoint.sh to conditionally apply ${L32} since we cna't use ARG
# values within an actual ENTRYPOINT command.  :(
RUN echo "#!/bin/bash" > /entrypoint.sh; \
    echo "${L32} \"\$@\"" >> /entrypoint.sh; \
    chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
CMD ["/bin/bash"]
USER buildworker
